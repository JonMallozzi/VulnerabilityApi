package com.jonmallozzi.vulnerabilityapi.Repository;

import com.jonmallozzi.vulnerabilityapi.MockData.MockVulnerability;
import com.jonmallozzi.vulnerabilityapi.Model.Vulnerability;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;

public class VulnerabilityRepositoryTest {
    VulnerabilityRepository vulnerabilityRepository;

    Map<String, Vulnerability> mockVulnerabilities = new MockVulnerability().vulnerabilities;
    MockVulnerability mockVulnerability;

    @BeforeEach
    void setUp() {
        vulnerabilityRepository = new VulnerabilityRepository(new MockVulnerability().vulnerabilities);
        mockVulnerability = new MockVulnerability();
    }


    @Test
    void findAll() {
        // when:
        Map<String, Vulnerability> result = vulnerabilityRepository.findAll();

        // then:
        assertThat(result).isEqualTo(vulnerabilityRepository.getVulnerabilities());
    }

    @Test
    void itGetsVulnerabilityById() {
        // given:
        String id = "CVE-2022-27607";

        // when:
        Vulnerability result = vulnerabilityRepository.getById(id);

        // then:
        assertThat(result).isEqualTo(mockVulnerabilities.get(id));
    }

    @Test
    void itGetsVulnerabilitiesForAGivenSoftware() {
        // given:
        String software = "Bento4";

        // when:
        Iterable<Vulnerability> result = vulnerabilityRepository.getForSoftware(software);

        // then:
        assertThat(result).contains(mockVulnerability.vulnerability, mockVulnerability.vulnerabilityV3, mockVulnerability.vulnerabilityV2);
    }

    @Test
    void itGetsVulnerabilitiesByV3Severity() {
        // given:
        String severity = "HIGH";

        // when:
        Iterable<Vulnerability> result = vulnerabilityRepository.getByV3Severity(severity);

        // then:
        assertThat(result).containsExactlyInAnyOrder(mockVulnerability.vulnerability, mockVulnerability.vulnerabilityV3);
    }

    @Test
    void itGetsVulnerabilitiesByV2Severity() {
        // given:
        String severity = "MEDIUM";

        // when:
        Iterable<Vulnerability> result = vulnerabilityRepository.getByV2Severity(severity);

        // then:
        assertThat(result).containsExactlyInAnyOrder(mockVulnerability.vulnerability, mockVulnerability.vulnerabilityV2);
    }

    @Test
    void itGetsVulnerabilitiesByV3AttackVector() {
        // given:
        String accessVector = "NETWORK";

        // when:
        Iterable<Vulnerability> result = vulnerabilityRepository.getByV3AttackVector(accessVector);

        // then:
        assertThat(result).containsExactlyInAnyOrder(mockVulnerability.vulnerability, mockVulnerability.vulnerabilityV3);
    }

    @Test
    void itGetsVulnerabilitiesByV2AccessVector() {
        // given:
        String accessVector = "NETWORK";

        // when:
        Iterable<Vulnerability> result = vulnerabilityRepository.getByV2AccessVector(accessVector);

        // then:
        assertThat(result).containsExactly(mockVulnerability.vulnerability, mockVulnerability.vulnerabilityV2);
    }

    @Test
    void itSavesAGivenVulnerability() {
        // given:
        Vulnerability newVulnerability = mockVulnerability.vulnerabilityNew1;
        String newVulnerabilityId = newVulnerability.getCve().getCVE_data_meta().getID();

        // when:
        vulnerabilityRepository.save(newVulnerability);

        // then:
        Map<String, Vulnerability> vulnerabilityRepositoryMapAfterSave = vulnerabilityRepository.getVulnerabilities();
        assertThat(vulnerabilityRepositoryMapAfterSave).containsEntry(newVulnerabilityId, newVulnerability);
    }

    @Test
    void itSavesMultipleVulnerabilities() {
        // given:
        List<Vulnerability> newVulnerabilities = List.of(
                mockVulnerability.vulnerabilityNew1,
                mockVulnerability.vulnerabilityNew2
        );

        // when:
        vulnerabilityRepository.saveMultiple(newVulnerabilities);

        // then:
        Map<String, Vulnerability> vulnerabilityRepositoryMapAfterSave = vulnerabilityRepository.getVulnerabilities();
        assertThat(vulnerabilityRepositoryMapAfterSave).containsValues(
                mockVulnerability.vulnerabilityNew1,
                mockVulnerability.vulnerabilityNew2

        );
    }

    @Test
    void itUpdatesAGivenVulnerability() {
        // given:
        Vulnerability vulnerability = mockVulnerability.vulnerability;
        vulnerability.getCve().getCVE_data_meta().setASSIGNER("jon@jon.com");
        String vulnerabilityId = vulnerability.getCve().getCVE_data_meta().getID();

        // when:
        vulnerabilityRepository.update(vulnerability);

        // then:
        Map<String, Vulnerability> vulnerabilityRepositoryMapAfterUpdate = vulnerabilityRepository.getVulnerabilities();
        assertThat(vulnerabilityRepositoryMapAfterUpdate).containsEntry(vulnerabilityId, vulnerability);
    }

    @Test
    void itDeletesAGivenVulnerability() {
        // given:
        Vulnerability vulnerability = mockVulnerability.vulnerability;
        String id = vulnerability.getCve().getCVE_data_meta().getID();

        // when:
        vulnerabilityRepository.delete(id);

        // then:
        Map<String, Vulnerability> vulnerabilityRepositoryMapAfterDelete = vulnerabilityRepository.getVulnerabilities();
        assertThat(vulnerabilityRepositoryMapAfterDelete).doesNotContainEntry(id, vulnerability);
    }
}
