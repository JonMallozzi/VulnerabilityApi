package com.jonmallozzi.vulnerabilityapi.Service;

import com.jonmallozzi.vulnerabilityapi.Exceptions.Vulnerability.VulnerabilityAlreadyExists;
import com.jonmallozzi.vulnerabilityapi.Exceptions.Vulnerability.VulnerabilityDoesNotExist;
import com.jonmallozzi.vulnerabilityapi.MockData.MockVulnerability;
import com.jonmallozzi.vulnerabilityapi.Model.Vulnerability;
import com.jonmallozzi.vulnerabilityapi.Repository.VulnerabilityRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;

@ExtendWith(MockitoExtension.class)
class VulnerabilityServiceTest {

    @Mock
    private VulnerabilityRepository vulnerabilityRepository;
    @Mock
    private Vulnerability vulnerability;

    @Captor
    private ArgumentCaptor<List<Vulnerability>> vulnerabilityListArgumentCaptor;
    @Captor
    private ArgumentCaptor<Vulnerability> vulnerabilityArgumentCaptor;

    private VulnerabilityService vulnerabilityService;

    @BeforeEach
    void setUp() {
        vulnerabilityService = new VulnerabilityService(vulnerabilityRepository);
    }

    @Test
    void itShouldListAllVulnerabilities() {
        // when:
        vulnerabilityService.list();

        // then:
        verify(vulnerabilityRepository).findAll();
    }

    @Test
    void itShouldGetVulnerabilityById() {
        // given:
        String id = "CVE-2020-25176";

        // when:
        vulnerabilityService.getById(id);

        // then:
        verify(vulnerabilityRepository).getById(id);
    }

    @Test
    void itShouldGetVulnerabilityForSoftware() {
        // given:
        String software = "github";

        // when:
        vulnerabilityService.getForSoftware(software);

        // then:
        verify(vulnerabilityRepository).getForSoftware(software);
    }

    @Test
    void itShouldGetVulnerabilityByV3Severity() {
        // given:
        String severity = "high";

        // when:
        vulnerabilityService.getByV3Severity(severity);

        // then:
        verify(vulnerabilityRepository).getByV3Severity(severity);
    }

    @Test
    void itShouldGetVulnerabilityByV2Severity() {
        // given:
        String severity = "high";

        // when:
        vulnerabilityService.getByV2Severity(severity);

        // then:
        verify(vulnerabilityRepository).getByV2Severity(severity);
    }

    @Test
    void itShouldGetVulnerabilityByV3AttackVector() {
        // given:
        String attackVector = "network";

        // when:
        vulnerabilityService.getByV3AttackVector(attackVector);

        // then:
        verify(vulnerabilityRepository).getByV3AttackVector(attackVector);
    }

    @Test
    void itShouldGetVulnerabilityByV2AccessVector() {
        // given:
        String accessVector = "network";

        // when:
        vulnerabilityService.getByV2AccessVector(accessVector);

        // then:
        verify(vulnerabilityRepository).getByV2AccessVector(accessVector);
    }

    @Test
    void itShouldSaveVulnerabilities() {
        // given:
        Vulnerability vulnerability = new MockVulnerability().vulnerability;

        // when:
        vulnerabilityService.save(vulnerability);

        // then:
        verify(vulnerabilityRepository).save(vulnerabilityArgumentCaptor.capture());

        Vulnerability capturedVulnerability = vulnerabilityArgumentCaptor.getValue();

        assertThat(capturedVulnerability).isEqualTo(vulnerability);
    }

    @Test
    void itShouldThrowErrorWithDupVulnerabilities() {
        // given:
        Vulnerability vulnerability = new MockVulnerability().vulnerability;
        String id = vulnerability.getCve().getCVE_data_meta().getID();

        given(vulnerabilityRepository.getById(id)).willReturn(vulnerability);

        // then:
        assertThatThrownBy(() -> vulnerabilityService.save(vulnerability))
                .isInstanceOf(VulnerabilityAlreadyExists.class);

        verify(vulnerabilityRepository, never()).save(any());
    }

    @Test
    void itShouldSaveMultipleVulnerabilities() {
        // given:
        List<Vulnerability> vulnerabilities = List.of(this.vulnerability);

        // when:
        vulnerabilityService.saveMultiple(vulnerabilities);

        // then:
        verify(vulnerabilityRepository).saveMultiple(vulnerabilityListArgumentCaptor.capture());

        List<Vulnerability> capturedVulnerability = vulnerabilityListArgumentCaptor.getValue();

        assertThat(capturedVulnerability).isEqualTo(vulnerabilities);
    }

    @Test
    void itShouldUpdateVulnerability() {
        // given:
        Vulnerability vulnerability = new MockVulnerability().vulnerability;
        String id = vulnerability.getCve().getCVE_data_meta().getID();

        given(vulnerabilityRepository.getById(id)).willReturn(vulnerability);

        // when:
        vulnerabilityService.update(vulnerability);

        // then:
        verify(vulnerabilityRepository).update(vulnerabilityArgumentCaptor.capture());

        Vulnerability capturedVulnerability = vulnerabilityArgumentCaptor.getValue();

        assertThat(capturedVulnerability).isEqualTo(vulnerability);
    }

    @Test
    void itShouldThrowVulnerabilityNotFoundAndNotUpdate() {
        // given:
        Vulnerability vulnerability = new MockVulnerability().vulnerability;
        String id = vulnerability.getCve().getCVE_data_meta().getID();

        given(vulnerabilityRepository.getById(id)).willReturn(null);

        // then:
        assertThatThrownBy(() -> vulnerabilityService.update(vulnerability))
                .isInstanceOf(VulnerabilityDoesNotExist.class);

        verify(vulnerabilityRepository, never()).update(any());
    }

    @Test
    void itShouldDeleteTheVulnerability() {
        // given:
        Vulnerability vulnerability = new MockVulnerability().vulnerability;
        String id = vulnerability.getCve().getCVE_data_meta().getID();

        given(vulnerabilityRepository.getById(id)).willReturn(vulnerability);

        // when:
        vulnerabilityService.delete(id);

        // then:
        verify(vulnerabilityRepository).delete(id);
    }

    @Test
    void itShouldThrowVulnerabilityNotFoundAndNotDelete() {
        // given:
        Vulnerability vulnerability = new MockVulnerability().vulnerability;
        String id = vulnerability.getCve().getCVE_data_meta().getID();

        given(vulnerabilityRepository.getById(id)).willReturn(null);

        // then:
        assertThatThrownBy(() -> vulnerabilityService.delete(id))
                .isInstanceOf(VulnerabilityDoesNotExist.class);

        verify(vulnerabilityRepository, never()).delete(any());
    }
}